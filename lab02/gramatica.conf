S -> S'
S' -> MAIN
MAIN -> CLASS_MAIN ID { MAIN_LIST_1 } MET
MAIN -> CLASS_MAIN ID { MAIN_LIST_2 } MET

MAIN_LIST_1 -> MA STATIC_MAIN TIPO_INT ID ( ) { LC RET } MET_MAIN
MAIN_LIST_1 -> MA STATIC_MAIN TIPO_INT ID ( TIPO_STRING [ ] ID ) { LC RET } MET_MAIN
MAIN_LIST_1 -> MA STATIC_MAIN TIPO_VOID ID ( ) { LC } MET_MAIN
MAIN_LIST_1 -> MA STATIC_MAIN TIPO_VOID ID ( TIPO_STRING [ ] ID ) { LC } MET_MAIN

MAIN_LIST_1 -> MA STATIC_MAIN ASYNC_MAIN TASK_MAIN ID ( ) { LC } MET_MAIN
MAIN_LIST_1 -> MA STATIC_MAIN ASYNC_MAIN TASK_MAIN ID ( TIPO_STRING [ ] ID ) { LC } MET_MAIN
MAIN_LIST_1 -> MA STATIC_MAIN ASYNC_MAIN TASK_MAIN < TIPO_INT > ID ( ) { LC RET } MET_MAIN
MAIN_LIST_1 -> MA STATIC_MAIN ASYNC_MAIN TASK_MAIN < TIPO_INT > ID ( TIPO_STRING [ ] ID ) { LC RET } MET_MAIN

MAIN_LIST_2 -> STATIC_MAIN TIPO_INT ID ( ) { LC RET } MET_MAIN
MAIN_LIST_2 -> STATIC_MAIN TIPO_INT ID ( TIPO_STRING [ ] ID ) { LC RET } MET_MAIN
MAIN_LIST_2 -> STATIC_MAIN TIPO_VOID ID ( ) { LC } MET_MAIN
MAIN_LIST_2 -> STATIC_MAIN TIPO_VOID ID ( TIPO_STRING [ ] ID ) { LC } MET_MAIN

MAIN_LIST_2 -> STATIC_MAIN ASYNC_MAIN TASK_MAIN ID ( ) { LC } MET_MAIN
MAIN_LIST_2 -> STATIC_MAIN ASYNC_MAIN TASK_MAIN ID ( TIPO_STRING [ ] ID ) { LC } MET_MAIN
MAIN_LIST_2 -> STATIC_MAIN ASYNC_MAIN TASK_MAIN < TIPO_INT > ID ( ) { LC RET } MET_MAIN
MAIN_LIST_2 -> STATIC_MAIN ASYNC_MAIN TASK_MAIN < TIPO_INT > ID ( TIPO_STRING [ ] ID ) { LC RET } MET_MAIN

TIPO_GERAL -> TIPO
TIPO_GERAL -> TIPO_INT
TIPO_GERAL -> TIPO_VOID
TIPO_GERAL -> TIPO_STRING


PC_GERAL -> PC
PC_GERAL -> STATIC_MAIN
PC_GERAL -> ASYNC_MAIN
PC_GERAL -> TASK_MAIN
PC_GERAL -> CLASS_MAIN
PC_GERAL -> USING_LIB

MET -> 
MET -> MA_GERAL CLASS_MAIN { MET_LIST }
MET_MAIN -> MET_LIST
MET_LIST -> MA_GERAL TIPO_VOID ID ( PAR ) { LC } MET_LIST
MET_LIST -> MA_GERAL TIPO_INT ID ( PAR ) { LC RET } MET_LIST
MET_LIST -> MA_GERAL MA_SEALED ID ( PAR ) { LC } MET_LIST
MET_LIST -> MA_GERAL MA_ABSTRACT ID ( PAR ) { LC } MET_LIST
MET_LIST -> 

RET -> RETURN EXP ;

PAR -> 
PAR -> B
B -> TIPO_GERAL EXP
B -> TIPO_GERAL EXP , B

MA_GERAL -> 
MA_GERAL -> MA

LC -> 
LC -> ARRAY
LC -> INST_IF
LC -> INST_WL
LC -> ATB
LC -> DECL
LC -> CALL_FUNC

INST_IF -> if ( EXP ) { LC } LC
INST_IF -> if ( EXP ) { LC } else { LC } LC

INST_WL -> while ( EXP ) { LC } LC

ARRAY -> TIPO_GERAL [ ] ID ; LC

DECL -> TIPO_GERAL ID ; LC
DECL -> ID ID = new ID ( ) ; LC

ATB -> ID = new TIPO_GERAL [ ] { EXP } ; LC
ATB -> TIPO_GERAL ID = EXP ; LC
ATB -> ID = EXP ; LC

CALL_FUNC -> ID . ID ( PAR_EXP ) ; LC

PAR_EXP -> 
PAR_EXP -> C
C -> EXP
C -> EXP , C

EXP -> EXP OP1 E0
OP1 -> =
OP1 -> +=
OP1 -> -=
OP1 -> *=
OP1 -> /=
OP1 -> %=
OP1 -> &=
OP1 -> |=
OP1 -> ^=
OP1 -> <<=
OP1 -> >>=
OP1 -> >>>=
OP1 -> ??=
OP1 -> =>
EXP -> E0
E0 -> E0 OP2 E1
OP2 -> ??
E0 -> E1
E1 -> E1 OP3 E2
OP3 -> ||
E1 -> E2
E2 -> E2 OP4 E3
OP4 -> &&
E2 -> E3
E3 -> E3 OP5 E4
OP5 -> |
E3 -> E4
E4 -> E4 OP6 E5
OP6 -> ^
E4 -> E5
E5 -> E5 OP7 E6
OP7 -> &
E5 -> E6
E6 -> E6 OP8 E7
OP8 -> ==
OP8 -> !=
E6 -> E7
E7 -> E7 OP9 E8
OP9 -> <
OP9 -> >
OP9 -> <=
OP9 -> >=
OP9 -> as
OP9 -> is
E7 -> E8
E8 -> E8 OP10 E9
OP10 -> <<
OP10 -> >>
OP10 -> >>>
E8 -> E9
E9 -> E9 OP11 E10
OP11 -> -
OP11 -> +
E9 -> E10
E10 -> E10 OP12 E11
OP12 -> *
OP12 -> /
OP12 -> %
E10 -> E11
E11 -> E11 OP13 E12
OP13 -> switch
OP13 -> with
E11 -> E12
E12 -> ! F
E12 -> F
F -> ID
F -> ID [ NUM ]
F -> REAL
F -> CHAR
F -> UNICODE
F -> STRING
F -> ID . ID ( PAR_EXP ) 
F -> NUM
F -> ( EXP )